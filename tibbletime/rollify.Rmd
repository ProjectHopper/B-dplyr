rollify Create a rolling version of any function
Description
rollify returns a rolling version of the input function, with a rolling window specified by the user.
Usage
rollify(.f, window = 1, unlist = TRUE, na_value = NULL)
Arguments
.f A function, formula, or atomic vector.
If a function, it is used as is.
If a formula, e.g. ~ .x + 2, it is converted to a function. There are three ways
to refer to the arguments:
• For a single argument function, use .
• For a two argument function, use .x and .y
• For more arguments, use ..1, ..2, ..3 etc
This syntax allows you to create very compact anonymous functions.
If character vector, numeric vector, or list, it is converted to an extractor function.
Character vectors index by name and numeric vectors index by position;
use a list to index by position and name at different levels. Within a list, wrap
strings in get-attr() to extract named attributes. If a component is not present,
the value of .default will be returned.
20 rollify
window The window size to roll over
unlist If the function returns a single value each time it is called, use unlist = TRUE.
If the function returns more than one value, or a more complicated object (like a
linear model), use unlist = FALSE to create a list-column of the rolling results.
na_value A default value for the NA values at the beginning of the roll.
Details
The intended use of rollify is to turn a function into a rolling version of itself for use inside of a
call to dplyr::mutate(), however it works equally as well when called from purrr::map().
Because of it’s intended use with dplyr::mutate(), rollify creates a function that always returns
output with the same length of the input, aligned right, and filled with NA unless otherwise specified
by na_value.
The form of the .f argument is the same as the form that can be passed to purrr::map(). Use .x
or . to refer to the first object to roll over, and .y to refer to the second object if required. The
examples explain this further.
If optional arguments to the function are required, specify them in the call to rollify, and not in
the call to the rolling version of the function. See the examples for more details.
See Also
purrr::safely, purrr::possibly
Examples
# Rolling mean --------------------------------------------------------------
data(FB)
# Turn the normal mean function into a rolling mean with a 5 row window
mean_roll_5 <- rollify(mean, window = 5)
dplyr::mutate(FB,
normal_mean = mean(adjusted),
rolling_mean = mean_roll_5(adjusted))
# There's nothing stopping you from combining multiple rolling functions with
# different window sizes in the same mutate call
mean_roll_10 <- rollify(mean, window = 10)
dplyr::mutate(FB,
rolling_mean_5 = mean_roll_5(adjusted),
rolling_mean_10 = mean_roll_10(adjusted))
# Functions with multiple args and optional args ----------------------------
# With 2 args, use the purrr syntax of ~ and .x, .y
# Rolling correlation example
cor_roll <- rollify(~cor(.x, .y), window = 5)
rollify 21
dplyr::mutate(FB, running_cor = cor_roll(adjusted, open))
# With >2 args, create an anonymous function with >2 args or use
# the purrr convention of ..1, ..2, ..3 to refer to the arguments
avg_of_avgs <- rollify(function(x, y, z) {
(mean(x) + mean(y) + mean(z)) / 3
},
window = 10)
# Or
avg_of_avgs <- rollify(~(mean(..1) + mean(..2) + mean(..3)) / 3,
window = 10)
dplyr::mutate(FB, avg_of_avgs = avg_of_avgs(open, high, low))
# Optional arguments MUST be passed at the creation of the rolling function
# Only data arguments that are "rolled over" are allowed when calling the
# rolling version of the function
FB$adjusted[1] <- NA
roll_mean_na_rm <- rollify(~mean(.x, na.rm = TRUE), window = 5)
dplyr::mutate(FB, roll_mean = roll_mean_na_rm(adjusted))
# Returning multiple values -------------------------------------------------
data(FB)
# If the function returns >1 value, set the `unlist = FALSE` argument
# Running 5 number summary
summary_roll <- rollify(summary, window = 5, unlist = FALSE)
FB_summarised <- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised$summary_roll[[5]]
# dplyr::bind_rows() is often helpful in these cases to get
# meaningful output
summary_roll <- rollify(~dplyr::bind_rows(summary(.)), window = 5, unlist = FALSE)
FB_summarised <- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised %>%
dplyr::filter(!is.na(summary_roll)) %>%
tidyr::unnest(summary_roll)
# Rolling regressions -------------------------------------------------------
# Extending an example from R 4 Data Science on "Many Models".
# For each country in the gapminder data, calculate a linear regression
# every 5 periods of lifeExp ~ year
library(gapminder)
# Rolling regressions are easy to implement
22 tibbletime
lm_roll <- rollify(~lm(.x ~ .y), window = 5, unlist = FALSE)
gapminder %>%
dplyr::group_by(country) %>%
dplyr::mutate(rolling_lm = lm_roll(lifeExp, year))
# Rolling with groups -------------------------------------------------------
# One of the most powerful things about this is that it works with
# groups since `mutate` is being used
data(FANG)
FANG <- FANG %>%
dplyr::group_by(symbol)
mean_roll_3 <- rollify(mean, window = 3)
FANG %>%
dplyr::mutate(mean_roll = mean_roll_3(adjusted)) %>%
dplyr::slice(1:5)
floor_index A simple wrapper of lubridate::floor_date()
Description
This is a thin wrapper around a lubridate::floor_date() that works for hms, yearmon, and
yearqtr classes as well.
Usage
floor_index(x, unit = "seconds")
Arguments
x a vector of date-time objects
unit a character string specifying a time unit or a multiple of a unit to be rounded
to. Valid base units are second, minute, hour, day, week, month, bimonth,
quarter, season, halfyear and year. Arbitrary unique English abbreviations
as in the period() constructor are allowed. Rounding to multiple of units (except
weeks) is supported.
See Also
lubridate::floor_date()
16 parse_period
Examples
data(FB)
dplyr::mutate(FB, date2 = floor_index(date, "year"))
time_test <- create_series('00:00:00'~'12:00:00',
'1 minute', class = "hms")
dplyr::mutate(time_test, date2 = floor_index(date, "hour"))
getters Getters
Description
Accessors to attributes of tbl_time objects.
Usage
get_index_quo(.tbl_time)
get_index_char(.tbl_time)
get_index_col(.tbl_time)
get_index_time_zone(.tbl_time)
get_index_class(.tbl_time)
Arguments
.tbl_time A tbl_time object.
parse_period Parse a character period specification
Description
The period is parsed into frequency and period and returned as a named list.
Usage
parse_period(period)
partition_index 17
Arguments
period A character specification used for time-based grouping. The general format to
use is "frequency period" where frequency is a number like 1 or 2, and period
is an interval like weekly or yearly. There must be a space between the two.
Note that you can pass the specification in a flexible way:
• 1 Year: '1 year' / '1 Y' / '1 yearly' / 'yearly'
This shorthand is available for year, quarter, month, day, hour, minute, second,
millisecond and microsecond periodicities.
Additionally, you have the option of passing in a vector of dates to use as custom
and more flexible boundaries.
Examples
parse_period('2 day')
partition_index Partition an index vector into an integer vector representing groups
Description
partition_index() takes an index vector and returns an integer vector that can be used for grouping
by periods. This is the workhorse for many other tibbletime functions.
Usage
partition_index(index, period = "yearly", start_date = NULL, ...)
Arguments
index A vector of date indices to create groups for.
period A character specification used for time-based grouping. The general format to
use is "frequency period" where frequency is a number like 1 or 2, and period
is an interval like weekly or yearly. There must be a space between the two.
Note that you can pass the specification in a flexible way:
• 1 Year: '1 year' / '1 Y' / '1 yearly' / 'yearly'
This shorthand is available for year, quarter, month, day, hour, minute, second,
millisecond and microsecond periodicities.
Additionally, you have the option of passing in a vector of dates to use as custom
and more flexible boundaries.
start_date Optional argument used to specify the start date for the first group. The default
is to start at the closest period boundary below the minimum date in the supplied
index.
... Not currently used.
18 posixct_numeric_to_datetime
Details
This function is used internally, but may provide the user extra flexibility in some cases.
Grouping can only be done on the minimum periodicity of the index and above. This means that a
daily series cannot be grouped by minute. An hourly series cannot be grouped by 5 seconds, and so
on. If the user attempts this, an error will be thrown.
See Also
as_period(), collapse_index()
Examples
data(FB)
partition_index(FB$date, '2 year')
dplyr::mutate(FB, partition_index = partition_index(date, '2 day'))
posixct_numeric_to_datetime
Converting a posixct numeric time back to a classed datetime
Description
Converting a posixct numeric time back to a classed datetime
Usage
posixct_numeric_to_datetime(x, class = "POSIXct", ..., tz = NULL)
Arguments
x A posixct numeric vector
class The class to convert to
... Extra arguments passed on the the specific coercion function
tz The time zone to convert to. The default UTC is used if none is supplied
reconstruct 19
reconstruct Reconstruct an S3 class from a template
Description
This is an implementation of sloop::reconstruct() that users can ignore. Once sloop is on
CRAN, this function will be removed and that version will be used. It currently must be exported
for use in tidyquant.
Usage
reconstruct(new, old)
Arguments
new Freshly created object
old Existing object to use as template
rollify Create a rolling version of any function
Description
rollify returns a rolling version of the input function, with a rolling window specified by the user.
Usage
rollify(.f, window = 1, unlist = TRUE, na_value = NULL)
Arguments
.f A function, formula, or atomic vector.
If a function, it is used as is.
If a formula, e.g. ~ .x + 2, it is converted to a function. There are three ways
to refer to the arguments:
• For a single argument function, use .
• For a two argument function, use .x and .y
• For more arguments, use ..1, ..2, ..3 etc
This syntax allows you to create very compact anonymous functions.
If character vector, numeric vector, or list, it is converted to an extractor function.
Character vectors index by name and numeric vectors index by position;
use a list to index by position and name at different levels. Within a list, wrap
strings in get-attr() to extract named attributes. If a component is not present,
the value of .default will be returned.
20 rollify
window The window size to roll over
unlist If the function returns a single value each time it is called, use unlist = TRUE.
If the function returns more than one value, or a more complicated object (like a
linear model), use unlist = FALSE to create a list-column of the rolling results.
na_value A default value for the NA values at the beginning of the roll.
Details
The intended use of rollify is to turn a function into a rolling version of itself for use inside of a
call to dplyr::mutate(), however it works equally as well when called from purrr::map().
Because of it’s intended use with dplyr::mutate(), rollify creates a function that always returns
output with the same length of the input, aligned right, and filled with NA unless otherwise specified
by na_value.
The form of the .f argument is the same as the form that can be passed to purrr::map(). Use .x
or . to refer to the first object to roll over, and .y to refer to the second object if required. The
examples explain this further.
If optional arguments to the function are required, specify them in the call to rollify, and not in
the call to the rolling version of the function. See the examples for more details.
See Also
purrr::safely, purrr::possibly
Examples
# Rolling mean --------------------------------------------------------------
data(FB)
# Turn the normal mean function into a rolling mean with a 5 row window
mean_roll_5 <- rollify(mean, window = 5)
dplyr::mutate(FB,
normal_mean = mean(adjusted),
rolling_mean = mean_roll_5(adjusted))
# There's nothing stopping you from combining multiple rolling functions with
# different window sizes in the same mutate call
mean_roll_10 <- rollify(mean, window = 10)
dplyr::mutate(FB,
rolling_mean_5 = mean_roll_5(adjusted),
rolling_mean_10 = mean_roll_10(adjusted))
# Functions with multiple args and optional args ----------------------------
# With 2 args, use the purrr syntax of ~ and .x, .y
# Rolling correlation example
cor_roll <- rollify(~cor(.x, .y), window = 5)
rollify 21
dplyr::mutate(FB, running_cor = cor_roll(adjusted, open))
# With >2 args, create an anonymous function with >2 args or use
# the purrr convention of ..1, ..2, ..3 to refer to the arguments
avg_of_avgs <- rollify(function(x, y, z) {
(mean(x) + mean(y) + mean(z)) / 3
},
window = 10)
# Or
avg_of_avgs <- rollify(~(mean(..1) + mean(..2) + mean(..3)) / 3,
window = 10)
dplyr::mutate(FB, avg_of_avgs = avg_of_avgs(open, high, low))
# Optional arguments MUST be passed at the creation of the rolling function
# Only data arguments that are "rolled over" are allowed when calling the
# rolling version of the function
FB$adjusted[1] <- NA
roll_mean_na_rm <- rollify(~mean(.x, na.rm = TRUE), window = 5)
dplyr::mutate(FB, roll_mean = roll_mean_na_rm(adjusted))
# Returning multiple values -------------------------------------------------
data(FB)
# If the function returns >1 value, set the `unlist = FALSE` argument
# Running 5 number summary
summary_roll <- rollify(summary, window = 5, unlist = FALSE)
FB_summarised <- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised$summary_roll[[5]]
# dplyr::bind_rows() is often helpful in these cases to get
# meaningful output
summary_roll <- rollify(~dplyr::bind_rows(summary(.)), window = 5, unlist = FALSE)
FB_summarised <- dplyr::mutate(FB, summary_roll = summary_roll(adjusted))
FB_summarised %>%
dplyr::filter(!is.na(summary_roll)) %>%
tidyr::unnest(summary_roll)
# Rolling regressions -------------------------------------------------------
# Extending an example from R 4 Data Science on "Many Models".
# For each country in the gapminder data, calculate a linear regression
# every 5 periods of lifeExp ~ year
library(gapminder)
# Rolling regressions are easy to implement
22 tibbletime
lm_roll <- rollify(~lm(.x ~ .y), window = 5, unlist = FALSE)
gapminder %>%
dplyr::group_by(country) %>%
dplyr::mutate(rolling_lm = lm_roll(lifeExp, year))
# Rolling with groups -------------------------------------------------------
# One of the most powerful things about this is that it works with
# groups since `mutate` is being used
data(FANG)
FANG <- FANG %>%
dplyr::group_by(symbol)
mean_roll_3 <- rollify(mean, window = 3)
FANG %>%
dplyr::mutate(mean_roll = mean_roll_3(adjusted)) %>%
dplyr::slice(1:5)
